# 控制器电池脚本适配说明

## 控制器电池脚本适配说明

## 版本

## 更新日期

## 更新说明

## 文档状态

## 维护责任人

## V1.0

### 2024.4.30

## 语雀迁移至飞书

## 使用中

## 厂家序列号：

### BatteryInformation.json
## 调试方式：
## （复选监听UDP端口方框可重启脚本）
syslog（3.4.6.2105版本之后，默认启用此方式记录，无需有线连接）
### log记录位置：下载日志后的syslog文件中
## 实时调试：

### tail -f /var/log/syslog
## image.png

## udp监听
选择通用脚本栏，点击所运行脚本并选中电池脚本，点击 监听UDP端口 ，即可在底部窗口显示调试信息，方便开发，如下图所示：
### （ 注意：udp监听需PC 网线连接控制状态下可用 ）
## image.png

## CAN电池穿透脚本
## 一、 前言
## (一) CAN相关概述
## 1. 标准CAN
## 标准CAN只有11位标识符：
1670921634411-37792416-64c7-47de-8d1e-903978133240.png

 SOF - 帧起始 ： 显性（逻辑0）表示报文的开始，并用于同步总线上的节点。
标识符 ： 标准CAN具有11位标识符，用来确定报文的优先级。此域的数值越小，优先级越高。
RTR - 远程发送请求位 ： 当需要从另一个节点请求信息时，此位为显性（逻辑0）。所有节点都能接收这个请求，但是帧标识符确定被指定的节点。响应数据帧同样被所有节点接收，可以被有兴趣的节点使用。
IDE - 标识符扩展位 ： 为显性时表示这是一个标准CAN格式，为隐形表示这是扩展CAN格式。
### r0 - 保留位 ：可能将来标准修订会使用
DLC - 4位数据长度代码 ： 表示传输数据的字节数目，一帧CAN最多传输8字节用户数据，此脚本发送8字节
### 数据0~8 : 最多可以传输8字节用户数据
CRC - 16位 ：包括1位定界符，CRC校验码用来校验用户数据区之前的（包含数据区）传输数据段。
ACK - 2位 ：包含应答位和应答界定符。发送节点的报文帧中，ACK两位是隐性位，当接收器正确地接收到有效的报文，接收器会在应答位期间向发送节点发送一个显性位，表示应答。如果接收器发现这帧数据有错误，则不向发送节点发送ACK应答，发送节点会稍后重传这帧数据。
EOF – 7位帧结束标志位 ： 全部为隐性位。如果这7位出现显性位，则会引起填充错误。
IFS – 7位帧间隔标志位 ： CAN控制器将接收到的帧正确的放入消息缓冲区是需要一定时间的，帧间隔可以提供这个时间。
### 2. CAN 总线信号传输
在 发送 过程，CAN控制器将CPU传来的信号转换为逻辑电平。CAN收发器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。
1670922679886-cfe33dca-21f4-4d93-b5fb-7aa21937aa7e.jpeg

在 接收 过程，CAN收发器将CAN_H 和 CAN_L 线上传来的差分电平转换为逻辑电平输出到CAN控制器，CAN控制器再把该逻辑电平转化为相应的信号发送到CPU上。

1670922693784-a3e3632f-634c-48a7-a0d1-012f95b994c7.jpeg

发送方通过CAN收发器使总线电平发生变化，将其信息传递到CAN总线上。接收方通过监听总线电平，将总线上的消息读入自己的CAN收发器。

## (二) 脚本使用流程说明
## 1. 模型文件配置使用
打开 battery 模型文件，选择brand分支下 byNetCan ，并在 scriptName 中输入需要运行使用的脚本文件即可，如图所示：
1670926703479-8a52a003-7f40-4f11-8a34-03e13feb1bef.png

打开CAN模型文件，创建CAN模型并填写所需can通道与波特率，如图所示：
1670926907954-26c9a50c-983a-464d-8dcb-2fdc4c839481.png

## (三) 学习资料

## 电池穿透协议培训视频.mp4

## 穿透脚本--李泽晨 -(1).pptx
## Python 教程|极客教程
## (四) 注：
升级3.4.7.1000及之后版本的整包，can电池脚本通道配置修改为模型配置，不再需要python手改，默认值为port2（若升级整包后出现电池问题，请拉取模型后检查bynet2Can--canport默认配置是否与实际电池接线一致）
## image.png

### 二、 X86 CAN电池穿透
## *条件：
## SRC2000
### Robokit版本在3.4.4.6及以上
## 固件版本2.1.40及以上
### roboshop版本2.4.1.84及以上
## 电池为CAN通信方式
## (一) 相关理论
## 1. CAN邮箱设定原理
控制器此功能采用Device：STM32F407，设定至多可attach（绑定）四个虚拟邮箱id进行接收底层上传CanFrame信息判别，并分别进行不同功能操作。
使用CAN通讯需要绑定指定编号来接收此编号的所有信息与内容，其余编号则不接收，此处用邮箱与id来看待更易理解，详细接口使用逻辑见Python脚本接口解析。
### 2. 更多
CAN总线入门知识_标准can和扩展can区别-CSDN博客
## CAN通讯系列--CAN通讯简介1
### CAN 邮箱的理解_can邮箱-CSDN博客

## (二) 脚本库函数详析
## 1. canpass_base 库函数使用说明：
## 一、 发送CanFrame信息
def sendCanframe(self,channel,can_id,dlc,extend,can_string):
## """
## 发送can信息至底层
### channel: can通讯通道选择（1或2）
## can_id：can信息id编号
## dlc：数据位长度（至多8）
    extend: 是否为扩展帧（True 或 False）,True表示扩展帧
    can_string：can数据信息，填写格式（"00 00 00 00 00 00 00 00"）
## """
    self.__rpc_client.sendPassThroughCanFrame(channel,can_id,dlc,extend,can_string)
### 二、 绑定多个邮箱（ rbk3.4.5.24及以上 ）
def attachCanID(self, channel, id_nums, can_id1, can_id2, can_id3, can_id4):
## """
## 绑定多个can邮箱
## channel：选择CAN通道
## id_nums：绑定邮箱的个数
    can_id1--can_id4: 至多可绑定四个邮箱id，不需绑定时填0即可
## """
    self.__rpc_client.canPassThroughRxId(channel, id_nums, can_id1, can_id2, can_id3, can_id4)
### print("attachCanID")
### 三、 设置接收回调
### def setCallBack(self):
## """
### 设置回调，待子类实现handleData方法接收信息
## """
### if not self.handleData:
        print("Set callback error.It should be implemented the func 'handleData'")
## else:
        self.__pass.setCallBack(self.handleData)
### 四、 接收CanFrame信息并转换
### def recCanframe(self,msg):
## """
## 接收信息并转化为can类型
## """
    rec_canframe = CanFrame_pb2.CanFrame()
    rec_canframe.ParseFromString(msg)
## return rec_canframe
### 五、 发布电池信息
def publish(self, battery_info):
## """
### 传入Message_Battery对象，发布
## """
    type_exm = message_battery_pb2.Message_Battery()
    if(isinstance(battery_info, type(type_exm))):
        msg = MessageToJson(battery_info)
        self.__rpc_client.publishBattery(msg)
## else:
        print("Publish battery info type error.")
### 六、 创建电池对象
def createBatteryMessage(self):
## """
## 创建Message_Battery对象
## """
    return message_battery_pb2.Message_Battery()
### 七、 设置电池通信超时警告
### def setTimeout(self):
## """
### 设置电池通信超时警告,错误码为54001
## """
    self.__rpc_client.setWarning(54001, "can Battery response time out")
    print("CAN Battery response time out")
### 八、 清除电池通信超时警告
### def clearTimeout(self):
## """
### 清除电池通信超时警告,错误码为54001
## """
    self.__rpc_client.clearWarning(54001)
    print("clear can Battery response time out")
### 九、 设置需要充电标志
### def setChargeStateOn(self):
## """
## 设置需要充电标志
## """
### self.need_charge = True
### 十、 设置不需要充电标志
### def setChargeStateOff(self):
## """
## 设置不需要充电标志
## """
### self.need_charge = False
### 十一、 判定是否需要充电标志
### def isNeedCharge(self):
## """
## 返回是否需要充电标志
## """
### return self.need_charge
## image.png

当配置的switchdo触发（充电do）则isNeedCharge为true
### 十二、 数据段字符串格式转换
### def getCanString(self, data):
## """
### 将candata转换为每个字节空格空开的字符串格式
## example：
    can_data = [tem[0:2], tem[2:4], tem[4:6], tem[6:8], '00', '00', '00', '00']
    can_string = self.getCanString(can_data)
## print(can_string)
### 则得到‘02 58 01 f4 00 00 00 00’
## """
### can_string = ' '.join(data)
## return can_string
### 十三、 获取 DI 状态
### def getDIStates(self,index):
## """
    调用DSP插件函數getDOStates(uint16_t index)获取DI状态
## """
    return self.__rpc_client.getDIStates(index)
### 十四、 获取 DO 状态
### def getDOStates(self,index):
## """
    调用DSP插件函數getDOStates(uint16_t index)获取DO状态
## """
    return self.__rpc_client.getDOStates(index)
### 2. char_utility 库函数使用说明：
## 一、 合并两个字节
def merge2bytesTo1(byte1, byte2):
## '''
## 将两个字节数据组合成一个16位的数据
## '''
### temp1 = byte1 << 8 & 0xFF00
### temp2 = byte2 & 0x00FF
### return temp1 | temp2
### 二、 合并四个字节
def merge4bytesTo1(byte1, byte2, byte3, byte4):
## '''
## 将四个字节数据组合成一个16位的数据
## '''
    temp1 = byte1 << 24 & 0xFF000000
    temp2 = byte2 << 16 & 0x00FF0000
    temp3 = byte3 << 8 & 0x0000FF00
### temp4 = byte4 & 0x000000FF
    return temp1 | temp2 | temp3 | temp4
### 三、 获取字节指定位数的数值
### def get_bit_val(byte, index):
## '''
    获取字节指定位数是1还是0，可用做对指定位数的变化做逻辑判断

## byte = 0b10101010
## index = 3
        print(get_bit_val(byte, index)) # 输出 1

## byte = 0b10101010
## index = 7
        print(get_bit_val(byte, index)) # 输出 0

## '''
### if byte & (1 << index):
## return 1
## else:
## return 0
### 四、 十六进制数转十进制数（补码形式）
def hexStr_to_int(hex_str,Reserved_Digits):
## '''
## hex_str：十六进制字符串数
### Reserved_Digits：指定需做补码形式的位数
### 补码形式做十六进制数转十进制数，用作有符号的数据显示
## '''
    binary_str = bin(int(hex_str, 16))[2:].zfill(Reserved_Digits)
### num = int(binary_str, 2)
### num_bits = len(binary_str)
### if binary_str[0] == '0':
## return num
## else:
        inverted = num ^ (2**num_bits - 1)
### return -1 * (inverted + 1)
### 五、 uint16_t的数据转换成int16_t
### def u16Toint16(u16t):
## '''
    将uint16_t的数据转换成int16_t,用途:负号转换
## '''
    return ctypes.c_int16(u16t).value
### 六、 uint8_t的数据转换成int8_t
## def u8Toint8(u8t):
## '''
### 将uint8_t的数据转换成int8_t,用途:负号转换
## '''
    return ctypes.c_int8(u8t).value
### (三) 脚本示例（btCanPass_demo.py）
## import sys
## # 导入电池基类
import syspy.battery_Can.canpass_base as cb
## # 其他工具类,如定时器
import syspy.lib.misc_utility as mu
import syspy.lib.udp_debug as ud
import syspy.lib.char_utility as cu

class testCanBattery(cb.canPassBase):

## def __init__(self):
## # 初始化基类,必须做
        super(testCanBattery, self).__init__()
        self.__debug_out = ud.udpDebug()
### sys.stdout = self.__debug_out
## # 创建一个超时定时器
        self.connect_timeout_t = mu.Timer(2000)
## # 用来表示数据是否已经正确接收
        self.battery_info = self.createBatteryMessage()
## self.msg_ok = False
## self.tem = ""

### def handleData(self,msg):
## # 清除超时错误
## self.clearTimeout()
## # 当打开充电开关
### if self.isNeedCharge():
### print("start charge")
            # 自问自答模式，需发送如此canframe信息等待上报，若主动上报模式则无需发送
            self.sendCanframe(2, 0x36, 8, False, "10 20 33 54 66 18 77 00")
        canframe = self.recCanframe(msg)
### # 当id为54时，取电压，当id为55时，取电流
        # 取date部分值将hex转int（根据实际协议自行设定，此处为示例）
### if canframe.ID == 0x36:
### tem = canframe.Data.hex()
            voltage = round(int(tem[2:4] + tem[0:2], 16) * 0.1, 2)
            self.battery_info.charge_voltage = voltage
## # 发步电池数据给rbk
            self.publish(self.battery_info)
## self.msg_ok = True
### elif canframe.ID == 0x37:
### tem = canframe.Data.hex()
            current = round(cu.hexStr_to_int(tem[0:2] + tem[2:4], 8) * 0.1, 2)
            self.battery_info.charge_current = current
## # 发步电池数据给rbk
            self.publish(self.battery_info)
## self.msg_ok = True

### def judgeMsgok(self):
## # 判断是否收到整包
## if self.msg_ok:
## # 重置标志位
## self.msg_ok = False
            self.connect_timeout_t.reset()
## else:
### # 等待是否收到整包,若超时则报超时,并进入下次循环
            if self.connect_timeout_t.isTimeUp():
## self.setTimeout()

## def loop(self):
### # 需要至少5s来等待底层初始化,否则将会覆盖操作
## mu.sleep_s(5)
        # 绑定多个can邮箱，2表示can通道2，3为绑定的邮箱个数，0x36，0x37，0x38分别为绑定的三个canid编号，0表示未绑定第四个邮箱（不可省略不写）
        self.attachCanID(2, 3, 0x36, 0x37, 0x38)
## while True:
## self.judgeMsgok()
## mu.sleep_s(2)

### if __name__ == '__main__':
### client = testCanBattery()
## client.loop()
### 三、 Aarch64 CAN电池穿透
## *条件：
### SRC800，SRC3000，SRC880
### rbk版本在3.4.5.32及以上，3.4.6.9及以上
## 固件版本2.1.40及以上
### roboshop版本2.4.1.126及以上
## python-can版本4.2.2
## 电池为CAN通信方式
## (一) 相关理论
Installation - python-can 4.3.1 documentation
## (二) 脚本库函数详析
## 1. canPassBase 库函数详析：
## 一、 创建CAN总线对象：
def createCanBus(self, channel, bitrate):
## """
### 创建了一个CAN总线对象，用于与CAN总线进行通信
    `bustype`参数指定了使用的总线类型，例如`socketcan`表示使用SocketCAN，`kvaser`表示使用Kvaser CAN，`pcan`表示使用PCAN等。
    `channel`参数指定了使用的通道号，用于指定连接到计算机的CAN总线接口。具体的通道号取决于使用的总线类型和硬件配置。
    `bitrate`参数指定了通信的比特率，即数据传输速率。它表示每秒传输的比特数，常见的比特率有100k、250k、500k、1M等。
## """
    self.bus = can.interface.Bus(bustype='socketcan', channel=channel, bitrate=bitrate)
    __msg_thread = threading.Thread(target=self.__run, name="run")
    __msg_thread.start()  # FIXME: when to join?
### 二、 过滤器（内部自动过滤，无需外部调用）：
### def can_filter(self, msg):
## """
    判断给定的CAN消息是否可以被过滤器过滤。如果给定的CAN消息的arbitration_id
    在过滤器的can_ids列表中，则返回True，否则返回False。
## """
    if msg.arbitration_id in self.can_ids:
## return True
## else:
## return False
### 三、 绑定指定CAN ID：
def attachCanID(self, *canid):
## """
     将传入的CAN ID添加到self.can_ids列表中，
     并根据CAN ID的大小设置相应的过滤器。最后，将过滤器应用到self.bus上。
## """
### for i in range(len(canid)):
### self.can_ids.append(canid[i])
## filters = []
### for id_ in self.can_ids:
## if id_ < 0x800:
## can_mask = 0x7FF
## else:
### can_mask = 0x1FFFFFFF
        filters.append({"can_id": id_, "can_mask": can_mask})
### self.bus.set_filters(filters)
    print('Attached CAN IDs:', end=' ')
### for id_ in self.can_ids:
### print(hex(id_), end=' ')
### 四、 发送CAN数据：
def sendCanframe(self,channel, can_id, dlc, extend, can_string:list):
## """
    example:sendCanframe('can2', 0x0DA20DF4, 8, True, [0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00])
## """
    bus = can.interface.Bus(channel, bustype='socketcan')
    msg = can.Message(arbitration_id=can_id, data=can_string, is_extended_id=extend, dlc=dlc)
## bus.send(msg)
    print(f'message send: channel={channel}, can_id={hex(can_id)}, dlc={dlc}, extend={extend}, can_string={can_string}')
## bus.shutdown()
### 五、 接收CAN数据（内部自动接收，无需外部调用）：
## def recvCan(self):
## """
### 对接收的数据用过滤器筛选，符合需求的数据则进入回调
## """
### for msg in self.bus:
### if self.can_filter(msg):
            if not self.__callback is None:
### self.__callback(msg)
## (三) 脚本示例
## # --coding:utf-8--
## import sys
## # 导入电池基类
import syspy.battery_Can.canpass_base as cb
## # 其他工具类,如定时器
import syspy.lib.misc_utility as mu
import syspy.lib.udp_debug as ud

class testCanBattery_arm(cb.canPassBase):

## def __init__(self):
## # 初始化基类,必须做
        super(testCanBattery_arm, self).__init__()
        self.__debug_out = ud.udpDebug()
### sys.stdout = self.__debug_out
        self.connect_timeout_t = mu.Timer(5000)
        self.battery_info = self.createBatteryMessage()
## # 用来表示数据是否已经正确接收
## self.msg_ok = False
## self.port1 = 'can0'
## self.port2 = 'can1'
## self.port3 = 'can2'
## self.tem = []

### def handleData(self, msg):
        if msg.arbitration_id == 0x019E:
## self.clearTimeout()
            # 取date部分值将hex转int（根据实际协议自行设定，此处为示例）
### tem = msg.data.hex()
            current = -round((int(tem[6:8] + tem[4:6], 16) - 32000) * 0.1, 2)
            voltage = round(int(tem[2:4] + tem[0:2], 16) * 0.1, 2)
            percentage = round(int(tem[8:10], 16) * 0.004, 2)
            self.battery_info.charge_voltage = voltage
            self.battery_info.charge_current = current
            self.battery_info.percetage = percentage
            self.publish(self.battery_info)
## self.msg_ok = True

### def judgeMsgok(self):
## if self.msg_ok:
## # 清除超时错误,重置标志位
## self.msg_ok = False
            self.connect_timeout_t.reset()
## else:
            if self.connect_timeout_t.isTimeUp():
## self.setTimeout()

## def loop(self):
## """
                这里的self.portX对应实际can通道接线的portX，CAN模型需要同步配置,880配置与实际接线通道相反需注意
## """
        self.createCanBus(self.port2, 250000)
        self.attachCanID(0x019E, 0x1806E5F4)
## while True:
### # 等待是否收到整包,若超时则报超时,并进入下次循环
            self.sendCanframe(self.port2, 0x0DA20DF4, 8, True, [0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00])
## self.judgeMsgok()
## mu.sleep_s(2)

### if __name__ == '__main__':
### client = testCanBattery_arm()
## client.loop()

## 串口电池穿透脚本
## 一、 前言
## (一) 串口相关概述
## 1. 报文解析举例
## RS232 或者 RS485
波特率 9600 或者 115200，数据位 8 位，无校验位，1 停止位。
## 协议版本：20
## 协议地址：01
需实现：获取模拟量量化后数据（CID2 为 42H）时的数据
1659273665184-567e3428-3e98-4492-8fbe-1b0c0612558f.png

## SRC-2000(S) 控制器发送 ：
7E 32 30 30 31 34 36 34 32 45 30 30 32 30 31 46 44 33 35 0D
## 电池回复示例：
7E 32 30 30 31 34 36 30 30  32 30 35 41 31 31 30 31  30 38 30 44 30 39 30
### 44 30 41 30 44 30 41 30 44 30 43 30 44 30 43 30 44 30 42 30 44 30 43 30 44
### 30 42 30 33 30 42 44 37 30 42 44 37 30 42 44 37 30 30 30 30 36 38 35 37 42
### 44 37 34 30 32 43 33 35 30 30 30 30 42 30 31 30 37 45 34 33 35 30 30 30 30
### 30 30 30 31 45 41 35 41 0D
1678420945932-7cadca0a-1f21-4128-8dcc-25038775d6f8.png

## normal：30 30 （固定）
字节长度：例 32 30 35 41，第一个字符 32 保持不变，后三个字符为有效数据 0x5A = 90（D）
## flag： 31 31（固定）
## pack： 电池包（目前只支持为 1）
## m： 电芯数（电压单位：1mV）
## n：温度传感器数量
温度单位：摄氏度，值为当前温度 +40℃。例如，报文温度数据为 80，则真实温度为 40°C。温度范围在 -40℃-120℃。
电流单位：10mA，有符号整形（充电为正），总电量和剩余电量要求单位为 10mA*h，并且在 uint16 类型下不会溢出。
## 用户字段：30 32（固定）
电池序列号：demo 中的电池序列号转换为十六进制为： 0107E43500000001
电池序列号由厂商 ID 和电池 ID 组成，一共 16 个字符，如 30 31 30 37 45 34 33 35 30 30 30 30 30 30 30 31 ；
第一第二字符为厂商 ID，转成十进制为 1，厂商 ID 由仙工分配，如需满足此协议，请向我司申请 ID 号；
第三到第六字符为年份，转成十进制为 2020，表示 2020 年；
第七第八字符为周数，转为十进制为 53，表示第 53 周；
第九到第十六字符为电池 ID 号，转为十进制为 1；
同厂商同一年下的电池序列号从 1 开始依次递增，次年 ID 归零，重新从 1 开始递增。

## (二) 脚本使用流程说明
## 1. 模型文件配置使用
### brand 修改为byNet2Serial
scriptName 为代码修改保存好后的脚本名称（全称加后缀）
## type 选择485还是232类型
### terminator 为终端电阻是否打开
## 波特率 选择电池的波特率
## 其他参数同正常电池一样进行配置
## 如图所示：
1654570157681-9342c27f-e22c-4eee-975d-3669121e286c.png

### 2. 脚本调试
## 一、 debug功能
当脚本无法正常工作时可以使用该方法进行调试，请注意不能在一个没有sleep的循环中使用，这会造成CPU负载偏高的问题。
print("data is {} {} {}".format(self.data_buff[0], self.data_buff[1], self.data_buff[2]))
## (三) 脚本库函数详析
## 1. battery_base 库函数使用说明：
## 一、 写入串口数据
### def write(self, msg):
## """
## 写入串口数据至底层
## """
### if(isinstance(msg, list)):
### self.__pass.send(bytes(msg))
## else:
        print("Write msg format error. please send a list")
### 二、 发送串口数据
### def send(self, msg:list):
## """
## 调用写入函数发送串口数据
## """
## self.write(msg)
### 三、 设置接收回调
### def setCallBack(self):
## """
### 设置回调，待子类实现handleData方法接收信息
## """
### if not self.handleData:
        print("Set callback error.It should be implemented the func 'handleData'")
## else:
        self.__pass.setCallBack(self.handleData)
### 四、 发布电池信息
def publish(self, battery_info):
## """
### 传入Message_Battery对象，发布
## """
    type_exm = message_battery_pb2.Message_Battery()
    if(isinstance(battery_info, type(type_exm))):
        msg = MessageToJson(battery_info)
        self.__rpc_client.publishBattery(msg)
## else:
        print("Publish battery info type error.")
### 五、 创建电池对象
def createBatteryMessage(self):
## """
## 创建Message_Battery对象
## """
    return message_battery_pb2.Message_Battery()
### 六、 设置电池通信超时警告
### def setTimeout(self):
## """
### 设置电池通信超时警告,错误码为54001
## """
    self.__rpc_client.setWarning(54001, "can Battery response time out")
    print("CAN Battery response time out")
### 七、 清除电池通信超时警告
### def clearTimeout(self):
## """
### 清除电池通信超时警告,错误码为54001
## """
    self.__rpc_client.clearWarning(54001)
    print("clear can Battery response time out")
### 八、 设置需要充电标志
### def setChargeStateOn(self):
## """
## 设置需要充电标志
## """
### self.need_charge = True
### 九、 设置不需要充电标志
### def setChargeStateOff(self):
## """
## 设置不需要充电标志
## """
### self.need_charge = False
### 十、 判定是否需要充电标志
### def isNeedCharge(self):
## """
## 返回是否需要充电标志
## """
### return self.need_charge
### 十一、 注册函数
def registerFunction(self, function, name = None):
## """
## 注册函数至上层，可实现dsp远程调用
## """
    self.__rpc_server.registerFunction(function, name)
### 十二、 获取 DI 状态
### def getDIStates(self,index):
## """
    调用DSP插件函數getDOStates(uint16_t index)获取DI状态
## """
    return self.__rpc_client.getDIStates(index)
### 十三、 获取 DO 状态
### def getDOStates(self,index):
## """
    调用DSP插件函數getDOStates(uint16_t index)获取DO状态
## """
    return self.__rpc_client.getDOStates(index)
### 2. char_utility 库函数使用说明：
## 一、 合并两个字节
def merge2bytesTo1(byte1, byte2):
## '''
## 将两个字节数据组合成一个16位的数据
## '''
### temp1 = byte1 << 8 & 0xFF00
### temp2 = byte2 & 0x00FF
### return temp1 | temp2
### 二、 合并四个字节
def merge4bytesTo1(byte1, byte2, byte3, byte4):
## '''
## 将四个字节数据组合成一个16位的数据
## '''
    temp1 = byte1 << 24 & 0xFF000000
    temp2 = byte2 << 16 & 0x00FF0000
    temp3 = byte3 << 8 & 0x0000FF00
### temp4 = byte4 & 0x000000FF
    return temp1 | temp2 | temp3 | temp4
### 三、 获取字节指定位数的数值
### def get_bit_val(byte, index):
## '''
    获取字节指定位数是1还是0，可用做对指定位数的变化做逻辑判断
## '''
### if byte & (1 << index):
## return 1
## else:
## return 0
### 四、 十六进制数转十进制数（补码形式）
def hexStr_to_int(hex_str,Reserved_Digits):
## '''
## hex_str：十六进制字符串数
### Reserved_Digits：指定需做补码形式的位数
### 补码形式做十六进制数转十进制数，用作有符号的数据显示
## '''
    binary_str = bin(int(hex_str, 16))[2:].zfill(Reserved_Digits)
### num = int(binary_str, 2)
### num_bits = len(binary_str)
### if binary_str[0] == '0':
## return num
## else:
        inverted = num ^ (2**num_bits - 1)
### return -1 * (inverted + 1)
### 五、 uint16_t的数据转换成int16_t
### def u16Toint16(u16t):
## '''
    将uint16_t的数据转换成int16_t,用途:负号转换
## '''
    return ctypes.c_int16(u16t).value
### 六、 uint8_t的数据转换成int8_t
## def u8Toint8(u8t):
## '''
### 将uint8_t的数据转换成int8_t,用途:负号转换
## '''
    return ctypes.c_int8(u8t).value
### 二、 X86 串口电池穿透
## *条件：
## SRC2000
### Robokit版本在3.3.5.58及以上
## 固件版本2.0.28及以上
### roboshop版本2.4.1.7及以上
### 电池为串口通信方式（RS232或RS485）
## (一) 脚本示例
roboshop界面》通用脚本》genetic文件夹》net2Serial_demo.py

## import sys
## #导入电池基类
import syspy.battery_Serial.battery_base as bb
#处理字符的工具类，处理字符的工具类，如将uint16_t的数据转换成int16_t,
#用途:负号转换，将两个字节数据组合成一个16位的数据，其他数据处理需要自行编写 
import syspy.lib.char_utility as cu 
## #其他工具类,如定时器
import syspy.lib.misc_utility as mu
## #打印工具类
import syspy.lib.udp_debug as ud

class testBattery(bb.batteryBase):
## """
## 继承电池基类
## """
## def __init__(self):
## #初始化基类,必须做
        super(testBattery,self).__init__()
## # 创建一个超时定时器
        self.connect_timeout_t = mu.Timer(6000)
        # 初始化打印工具，在代码中的print输出即可显示在调试窗口
        self.__debug_out = ud.udpDebug()
### sys.stdout = self.__debug_out
## #创建一个列表用来缓冲接收数据
## self.data_buff = []
## #用来表示数据是否已经正确接收
## self.msg_ok = False

    def handleData(self, msg:list):
## """
        必须实现基类中处理数据的handleData(msg)的函数)
## 如下为示例
## """
## #存入收到的数据到缓冲中
### self.data_buff.extend(msg)
### print(len(self.data_buff))
## # 判断报文长度
        while len(self.data_buff) >= 45:
## #校验帧头是否正确
### if self.data_buff[0] == 0xDD:
## # 转换电池数据
                voltage = cu.merge2bytesTo1(self.data_buff[4], self.data_buff[5]) * 0.01  # 电池电压
                current = cu.u16Toint16(cu.merge2bytesTo1(self.data_buff[6], self.data_buff[7])) * 0.01  # 是int16类型
                temp16_1 = (cu.merge2bytesTo1(self.data_buff[27], self.data_buff[28]) - 2731) * 0.1
                temp16_2 = (cu.merge2bytesTo1(self.data_buff[29], self.data_buff[30]) - 2731) * 0.1
                temperature = temp16_1  # 电池温度
### if temp16_1 < temp16_2:
### temperature = temp16_2
                percetage = cu.u16Toint16(self.data_buff[23]) * 0.01  # 电池电量百分比
                cycle = cu.merge2bytesTo1(self.data_buff[12], self.data_buff[13])  # 电池循环次数
## # 创建一个电池信息的proto对象
                battery_info = self.createBatteryMessage()
## # 解析后塞入相应字段
                battery_info.percetage = percetage
                battery_info.temperature = temperature
                battery_info.charge_current = current  # 电池电流：正表示在充电，负表示在放电
                battery_info.charge_voltage = voltage
### battery_info.cycle = cycle
                battery_info.max_charge_voltage = 58.4  # 最大充电电压
                battery_info.max_charge_current = 30  # 最大持续充电电流
## # 发步电池数据给rbk
### self.publish(battery_info)
## # 清除超时报警
## self.clearTimeout()
## # 清空缓冲区列表
## self.data_buff = []
## # 标记该次数据接收完成且正确
## self.msg_ok = True
## print("finish")
## else:
## # 第一个字节有误则去除
### self.data_buff.pop(0)

### def judgeMsgok(self):
## # 判断是否收到整包
## if self.msg_ok:
## # 清除超时错误,重置标志位
## self.msg_ok = False
            self.connect_timeout_t.reset()
## else:
            if self.connect_timeout_t.isTimeUp():
### # 等待是否收到整包,若超时则报超时,并进入下次循环
## self.setTimeout()

## def loop(self):
## """
## 循环,处理发送及超时逻辑
## """
## while True:
## #初始化查询报文list
            request = [0xDD,0xA5,0x03,0x00,0xFF,0xFD,0x77]
## #发送查询报文
## self.send(request)
## self.judgeMsgok()
## mu.sleep_s(2)

### if __name__ == '__main__':
### client = testBattery()
## client.loop()
## 1. handleData函数
该函数为处理报文数据的函数， 必须 实现。
其中从31行”#判断报文长度“开始，需要更改为针对该电池协议解析的处理逻辑，流程如下
32行，先判断电池报文是否接收完整（报文长度为105字节），
34行，判断该报文是否粘包（判断帧头是否为0x01），
36行-43行，以上两个判断正确后，开始解析报文，电池电压为报文第40和41字节组成的16 bits的数据，单位*0.01为V，其他数据同理
## 45行，创建一个电池发布消息对象
47行-50行分别赋值36-43行中解析的数据。
## 52行，发布电池信息
54行-56行，清空缓冲区，标记接收完成。
### 2. loop函数
### 其中从63行开始，为发送查询报文，处理超时逻辑，流程如下：
63行，创建一个超时定时器，用来判断是否电池通信断连。
## 64行，while循环开始
66行，发送报文的初始，电池协议中查询报文放在这里。
## 68行，发送查询报文
70行-74行，判断handleData函数是否收到整包，收到后清除超时，重置msg_ok标志，重置超时定时器。
76行-80行，阻塞等待handleData函数是否收到整包，若超时，则报超时，并等待1s后进入下一个循环。
### 三、 Aarch64 串口电池穿透
## *条件：
### SRC800，SRC3000，SRC880
Robokit版本在3.4.5.32及以上,3.4.6.9及以上
## 固件版本2.0.28及以上
### roboshop版本2.4.1.7及以上
### 电池为串口通信方式（RS232或RS485）
## (一) 脚本示例
roboshop界面》通用脚本》genetic文件夹》net2Serial_demo.py

注 ：aarch64穿透需要初始化串口信息，例如880控制器串口uart0对应/dev/ttyS8，具体按照控制器规格书适配
## import sys
## import os

## #导入电池基类
import syspy.battery_Serial.battery_base as bb
#处理字符的工具类，处理字符的工具类，如将uint16_t的数据转换成int16_t,
#用途:负号转换，将两个字节数据组合成一个16位的数据，其他数据处理需要自行编写。 
import syspy.lib.char_utility as cu 
## #其他工具类,如定时器
import syspy.lib.misc_utility as mu 

class testBattery(bb.batteryBase):
## """
## 继承电池基类
## """
## def __init__(self):
## #初始化基类,必须做
        super(testBattery,self).__init__()
        # aarch64穿透需要初始化串口信息，880控制器串口uart0对应/dev/ttyS8
        self.createSerial('/dev/ttyS8', 9600)
## #创建一个超时定时器
        self.connect_timeout_t = mu.Timer(2000)
## #创建一个列表用来缓冲接收数据
## self.data_buff = []
## #用来表示数据是否已经正确接收
## self.msg_ok = False

    def handleData(self, msg:list):
## """
        必须实现基类中处理数据的handleData(msg)的函数)
## 如下为示例
## """
## #存入收到的数据到缓冲中
### self.data_buff.extend(msg)
### print(len(self.data_buff))
## #判断报文长度
        while len(self.data_buff) >= 105:
## #校验帧头是否正确
### if self.data_buff[0] == 0x01:
## #转换电池数据
                voltage = cu.merge2bytesTo1(self.data_buff[39],self.data_buff[40]) * 0.01
                current = cu.u16Toint16(cu.merge2bytesTo1(self.data_buff[41],self.data_buff[42])) * 0.01    #是int16类型
                temp16_1 = (cu.merge2bytesTo1(self.data_buff[77],self.data_buff[78]) - 2731) * 0.1
                temp16_2 = (cu.merge2bytesTo1(self.data_buff[79],self.data_buff[80]) - 2731) * 0.1
### temperature = temp16_1
### if temp16_1 < temp16_2:
### temperature = temp16_2
                percetage = cu.merge2bytesTo1(self.data_buff[83],self.data_buff[84]) * 0.01
## #创建一个电池信息的proto对象
                battery_info = self.createBatteryMessage() 
## #解析后塞入相应字段
                battery_info.percetage = percetage  
                battery_info.temperature = temperature
                battery_info.charge_current = current
                battery_info.charge_voltage = voltage
## #发步电池数据给rbk
### self.publish(battery_info)
## # 清除超时报警
## self.clearTimeout()
## #清空缓冲区列表
## self.data_buff = []
## #标记该次数据接收完成且正确
## self.msg_ok = True
## print("finish")
## else:
## # 第一个字节有误则去除
### self.data_buff.pop(0)

### def judgeMsgok(self):
## # 超时检测函数
## if self.msg_ok:
## # 清除超时错误,重置标志位
## self.msg_ok = False
            self.connect_timeout_t.reset()
## else:
            if self.connect_timeout_t.isTimeUp():
## self.setTimeout()

## def loop(self):
## """
## 循环,处理发送及超时逻辑
## """
## while True:
## # 初始化查询报文list
            request = [0x01, 0x03, 0x00, 0x00, 0x00, 0x32, 0xC4, 0x1F]
## # 发送查询报文
## self.send(request)
## # 循环检测是否超时
## self.judgeMsgok()
## mu.sleep_s(2)

### if __name__ == '__main__':
### client = testBattery()
## client.loop()
