# ModbusTCP互斥组

## ModbusTCP互斥组
## @杨达
## 解决问题
### 通过ModbusTCP协议使用系统间互斥组
## 对接方式
RDSCore为ModbusSlave，即服务器，默认端口为502，不关心slaveId。
通过ModbusTCP协议查询互斥区状态；
通过ModbusTCP协议申请、释放互斥组；
## 配置
## 端口
在502端口无法使用的情况下，需要修改Core监听的端口，修改后需要重启Core

## 参数名称

## 默认值

## 版本

## ModbusSlavePort

## 502

## ~latest
### 在场景中，配置互斥组的属性 registers
### registers 为互斥组对应的寄存器列表
1655190516847-de4d6bb9-cc15-4063-aa89-7bcf181693e1.png

## 寄存器规则
假设配置的互斥区寄存器为 [A, B ,C, D] ，实际数量不限，此处为示例

## 目标

## 操作

## 函数号

## 寄存器

## 备注

## 查询互斥组所有者

## 读取寄存器

## 3

## A,B,C,D均可

### 返回1表示被外部系统占用，0表示被core占用

## 查询互斥区是否被占用

## 读取寄存器

## 3

## A+1,B+1,C+1,D+1均可

### 返回1表示被占用，0表示没有被任何系统占用

## 申请互斥组

## 批量写寄存器，值为1

## 16

## A+1,B+1,C+1,D+1均可

## 释放互斥组

## 批量写寄存器，值为0

## 16

## A+1,B+1,C+1,D+1均可

## 注意：
寄存器之间的间隔至少为2。
1653969672005-75896cce-98fb-4fa8-8158-862120ae6af5.png

例如，上图中，配置了寄存器100，则寄存器101也被占用，对应到表中，A为100，A+1为101。此时就不能配置99，因为99+1=100已经被使用；也不能配置101，因为101=100+1已经被使用。
## 批量操作：
批量申请、释放时，
### 将命令写到互斥组对应的任意一个的寄存器均可
如果同一个互斥组对应的多个寄存器分别收到了申请和释放指令，优先申请
## 其他
## 外部系统id
使用ModbusTCP协议操作互斥组的外部系统，id都为 "1" 。即，通过HTTP接口查询互斥组状态时，如果被使用ModbusTCP协议操作互斥组的系统占有，则id为 "1" 。
## [
## {
        "id": "1",
        "name": "104",
## "status": true
## }
## ]
